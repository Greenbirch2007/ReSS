


head first java



编写程序，编译，运行


java的工作方式

它的目标是要让你写出一个应用程序


源代码 (编写源代码文件)


编译器(用编译器运行源代码)

输出:编译器会产出字节码


java虚拟机(JVM)

用javac编译程序把文件进行编译，然后在某个Java虚拟机上执行编译
过的字节码


源文件(.java)带有类的定义。类用来表示程序的一个组件，
小程序或许只会一个类。类的内容必须包在花括号里面


类
public class Dog{}


类存于源文件里面
方法存于类中
语句(statement)存于方法中


什么是类？


类中带有一个或多个方法。在Gog这个类中，bark方法带有，方法必须在类的内部声明


public class Dog{
	void bark()
}

方法


什么是方法？


在方法的花括号中编写方法应该执行的指令。
方法代码是友一组语句所组成，你可以把方法想象成一个函数或过程。

public class Dog{
	void bark(){
	statement1;
	statement2;
}}



剖析类

当java虚拟机启动执行时，它会寻找在命令列所指定的类。然后它会锁定


public static void main(String[] args){
	}


接着Java虚拟机就会执行main方法在花括号间的函数所有指令。每个java程序
最少都会有一个类以及一个main().

每个应用程序只有一个main()函数


public  公开给其他类存取
class 类声明
MyClass 类的名称

{ 类的左括号

void 代表没有返回值 
main  方法的名称
String[]  必须要传String的数组给此方法当参数，命名为args

{ 方法 的左括号

out 打印到标准输出上(默认为命令行)
“ss” 要输出的字符串

;每一行结束都必须用分号结尾


编写带有main()的类

在java中的所有东西都会属于某个类


你会建立源文件(扩展名为.java)，然后将它编译成新的类文件(扩展名为.class)

真正被执行的是类


main()就是程序的起点


保存，编译，运行


1.做某事

声明，设定，调用方法等普通语句

int x  =3;
String name = "Dirk";
x = x *17;
System.out.Print("x is"+x);
double d = Math.random();


2. 反复某件事
for ,while的循环(loop)


while (x>12){
	x = x-1;
}


for (int x=0;x <10;x=x+1){
	System.out.print("x is now " +x);
}


空格符通常无关紧要

用名称与类型(type)来声明变量

类型与方法都必须定义在花括号中。

public void go(){}

3. 在适当条件做某件事


if/else 的条件分支测试

if (x==10){
	System.out.println("x must be 10");
}else{
	System.out.println("x isn't 10");
}


if ((x <3) & (name.equals("Dirt"))){
	System.out.println("Gently");
}
	System.out.println("this line runs no matter what");

while (moreBalls == true){
	keepJuggling());



int x =4;

while (x>3){
	x = x-1;
}


int z =27;
while (z==17){
	}


为何所有的东西都得包含在类中？

因为java是面向对象的语言，它不像是以前的程序语言那样。
类是对象的蓝图，而java中的绝大多数东西都是独享


并不是每一个类都需要加上一个main


java中的integer与boolean两种类型并不相容。

boolean isHot =true;
while(isHot){}


语句以分号结束
程序块以{}划出范围
用名称与类型声明变量
等号是赋值运算符
两个等号用来当等号运算符

只要条件测试结果为真，while循环就会一直执行块内的程序

把boolean测试放在括号中
while (x==4){}

system.out.println会在最后面插入换行，若你想让后续的输出以新的一行开始
可以使用println
若是使用print则后续的输出还是会在同一行


设计真正的应用程序


java编译器负责对.java文件编译成.class内文件(字节码文件，以供jvm使用)

jvm负责运行.class内文件，jvm最重要的作用是实现操作系统与代码的无关性(程序与操作系统分离
)
 	


2. 类与对象


以对象来思考

当你在设计类时，要记得对象是靠类的模型塑造出来的

对象是已知的事物
对象会执行的动作

对象本身已知的事物被称为实例变量(instance variable)


对象可以执行的动作被称为方法(methods)

实例变量(状态)

方法(行为)


对象本身已知的食物称为实例变量(instance variable)
它们代表对象的状态(数据)，且该类型的每一个对象都会独立的
拥有一份该类型的值


所以也可以把对象当作为实例


对象可以执行的打破给你做称为方法
在设计类时，也会设计出操作对象数据的方法。
对象带有读取或操作实例变量的方法是很常见的

对象带有实例变量和方法，但它们都是类设计中的一部分


到底类与对象两者之间有什么不同？



一个类和许多对象

类不是对象，却是用来创建对象的模型

类是对象的蓝图，它会告诉虚拟机如何创建某种类型的对象。根据某类
创建出的对象都会有自己的实例变量。

创建一个对象

如何才能运行对象？

需要两个类，一个是要被操作于对象的类,另一个是用来测试该类的类。

测试用的类带有main()并且会在其中建立与与存取被测的对象

. 圆点运算符能让你存取对象的状态与行为

//建立对象

Dog d = new Dog();

//通过操作和调用

method 
d.bark();

//通过操作数存取属性


d.size = 40;

编写类，实例变量，方法，
编写测试用的类
在测试用的类中建立对象并存取对象的变量和方法



main()的两种用途：

测试真正的类
启动你的Java应用程序

创建对象时，它会存放在称为 堆的内存区域中
不管对象如何创建都会放在此区域中。
此区域并非普通的堆；它是可回收垃圾的堆(Garbage-Collectible Heap)


java会根据对象的大小来分配内存空间。比如说15个实例变量的对象所占的空间就可能
会比只有两个实例变量的对象要打
java会主动管理内存。当某个对象被java虚拟机察觉不再会被使用到，该对象就会被标记
成可回收的。
如果内存开始不足，垃圾收集器就会启动来清理垃圾，回收空间，让空间能够再次被利用

全局变量


在任何类中的任何程序都可以存取public static的方法

任何变量只要加上public,static和final，基本上都会变成全局变量取用的常数


java程序是由一组类所组成，其中有一个类会带有启动用的main()方法
因此程序员必须要编写一或多个类进行提交
若用户没有java虚拟机则必须一并提交才能让应用程序运行起来


任何java中的事物都必须呆在类中。pi常数或random()类方法也必须定义在Math这个类中

而你必须记住这类近似全局的事物在Java中算是例如。
它们是非常特殊的情况，不会有多个实例或对象


面向对象设计扩展功能不需改动之前已经测试好的程序代码

所有的java程序都定义在类中

类如同j蓝图描述该类型的对象要如何创阿金


对象自治，你无需在意它如何完成任务

对象有已知的事物，并能执行工作

对象本身已知道的事物称为实例变量，它代表对象的状态
对象可执行的动作称为方法，它代表对象的行为

创建类时，可能同时会需要创建独立，测试用的类

类可以继承自较为抽象的父类

java的程序在执行期是一组会互相交谈的对象



认识变量

变量有两种：primitive主数据类型和引用

对象的状态(instace variable)与局部(local)变量(声明在方法中的变量)


会把变量用于参数(arguments,传递给方法的值)以及返回类型(执行方法所返回的值)

java很注重类型

声明变量

primitive主数据类型用来保存基本类型的值，包括整数，布尔和浮点数等
而对象引用保存的是对象的引用

变量必须拥有类型，

int count;
变量  名称

primitive主数据类型

类型 位数  值域

boolean 与char

boolean true或false
数值(带正负号)


integer

byte 8 bits

short 16 bits


int  32bits

long 64 bits


浮点数

float 32 bits
double 64 bits


primitive主数据类型的声明与赋值声明


int x;
x =234;
byte b =89;
boolean isFun =true;

double d =2222.3;
char c ="f";
int z= x;
boolean isPunkRock;

isPunkRock = false;
boolean powerOn ;
powerOn = isFun;
long big = 234;
float f =23.4f;


要确保变量能够存下所保存的值

不会出现溢出


避开股那件自


保留字

boolean,byte,char,double,float,int,long,
short,public,private,protected,abstract,final,native,
static,strictfp,syncthron,transient,volatile,if

else,do,while,switch,case,default,for,break,continue,
assert,
class,extends,implements,import ,instanceof,interface,
new,package,super,this,catch,finally,try,throw,return,
void,const,goto,enum

如何控制对象？

事实上没有对象变量这样的东西
只有引用(reference)到对象的变量
对象引用变量保存的是存取对象的方法

它并不是对象的容器，而是类似指向对象的指针或地址

在java中我们不会也不该知道引用变量中实际装载的是什么，
它只是用来代表单一的对象，只有Java虚拟机才会知道
如何使用引用来取得该对象


对象引用也只是一个变量值

对象的声明，创建与赋值有三步：

1.声明一个引用变量

要求java虚拟机分配空间给引用比那里，并一次变量命名，
此引用变量将永远被固定为Dog类型。

Dog MyDog
2. 创建对象

new Dog();
要求java虚拟机分配堆空间给新建立的Dog对象

3.连接对象和引用


需要关心的应该是需要建立多少个对象和引用，对象的实际大小

对于任意一个java虚拟机来说，所有的引用大小都一样，
但不同的java虚拟机间可能会以不同的方式来表示引用，因此某个java虚拟机的引用
大小可能会大于或小于另一个java虚拟机的引用

数组

1.声明一个int数组变量，数组变量是数组对象的遥控器
int[] nums;
2. 创建大小为7的数组，并将它赋值给之前声明为int[]的变量nums


nums = new int[7];


3.赋予int数组的每一个元素一个int值。
要记得在int数组中的每个元素皆为int类型的变量


数组也是对象

数组能够让你使用位置索引来快速，随机地存取其中的元素

数组中的每个元素都是变量。
主数据类型变量或这引用变量，可以放进该类型变量中的值都可以当作此类型数组的元素
所以在int类型的数组中，每个元素可以装载一个int

引用变量只会保存引用，而不是对象本身。

无论被声明来承载的是主数据类型或对象本身，数组永远是对象

创建Dog数组

1.声明一个Gog数组变量

Dog[] pets;


2. 创建大小为7的数组

pets = new Dog[7];

3.创建新的Dog对象并将他们赋值给数组的水元素

控制实例，通过引用变量

java注重类型
一旦数组被声明出来，就只能装入所声明类型的元素

我们对数组的操作可以不需要变量名称。只需要数组索引(位置；就可以操作特定对象了)

变量有两种：primitive主数据类型和引用
变量的声明必须有类型和名称

primitive主数据类型变量值是该值的字节所表示的


引用变量的值代表位于堆之对象的存取方法

没有引用到任何对象的引用变量的值为null值

数组一定是个对象，不管所声明的元素是否为主数据而理想呢
并且

第四章 方法操作实例变量

对象的行为

状态影响行为，行为状态。

对象有状态和行为两种属性，分别由实例变量与方法来表示。

类的每个实例(也即是特定类型的每个对象)可以维持自己的实例变量


记住：类所描述的是对象知道什么与执行什么？

类是对象的蓝图，在编写类时，你是在描述Java虚拟机应该如何
制作该类型的对象。
你已经知道每个对象有独立的实例变量值


同一类型的每个对象能够有不同的方法吗？

任一类的每个实例都带有相同的方法，但是方法可以根据实例
变量的值来表现不同的行为

可以传值给方法


可以能会用实参(argument)或形参(parameter)来调用传给
方法的参数。


方法会运用实参。调用的一方会传入实参


实参是传给方法的值。当它传入方法后就成了形参。

参数跟局部(local)变量是一样的。
它有类型与名称，可以在方法内运行。


重点是：如果某个方法需要参数，你就一定得传东西给他。那个
东西得是适当类型的值

1. 调用Dog上的bark()方法，并传入"3"这个值(作为此方法的参数)



Dog d = new Dog();
d.bark(3);


2.以int类型表示的值3会传递给bark()


3.此值会传给numOfBarks这个参数(int类型的变量)

void bark(int numOfBarks){
	while (numOfBarks>0){
	System.out.println("runff")
}}


4.把numOfBarks当做一般的变量使用

可以从方法中取返回值


方法可以有返回值。每个方法都声明返回的类型，但目前都是
把方法设成返回void类型，这代表并没有返回任何东西

void go(){}


但可以声明一个方法，回传给调用方指定的类型值，

int giveSecret(){
	return 68;
}



如果你将一个方法有返回值，你就必须返回所声明类型的值
(或是与声明类型兼容的值



int theSecret = life.giveSecret();

int giveSecret(){
	return 88;
}


可以向方法中传入一个以上的参数


方法可以有多个采纳数。在声明的时候要用逗号分开传入，
传入的时候要用逗号分开


最重要的是，如果方法有参数，你一定要以正确数量，类型和顺序来
传递参数。


调用需要两个参数的方法，并传入两个参数：
void go(){
	TestStuff t = new TestStuff();
	t.takeTwo(12,32);

}


传入的参数会以相同的顺序赋值。
第一个实参会赋值给第一个形参，以此类推


void takeTwo(int x,int y){
	int z = x+y;
	System.out.println("Total is"+z);
}



也可以将变量当做参数传入，只要类型相符就可以

void go(){
	int foo=7;
	int bar = 3;
	t.takeTwo(foo,bar);
}


void takeTwo(int x,int y){
	int z = x+y
	System.out.println("total is "+z);
}


java是通过值传递的
也就是通过拷贝传递

int x =7;
声明一个int类型的变量并赋值给7,代表7的字节组合会放进称为x的变量中


void go(int z){} 

声明一个有int参数的方法，参数名称为z

foo.go(x);

void go(int z){}

以x为参数传入go()这个方法中，x的字节组合会被拷贝并装进z中


void go(int z){
	z =0;
}


在方法中改变z的值，此时x的值不会改变，传给z的只是一个拷贝

方法无法改变调用方所传入的参数



方法只能声明单一的返回值。若你需要返回3个int值。
就把返回类型说明为int的数组，将值装进数组中来返回。


可以返回会被隐含转换成声明类型的其他类型值。
例如说用byte当做int类型的返回。但若声明的类型容量
小鱼想要返回的类型时，必须作明确的转换

java并未要求一定要处理返回值。
你可以调用返回非void类型的方法而不必理会返回值，这代表你要的是
方法的行为而不是返回值。可以不指派返回值

类定义对象所知的行为

运用参数与返回类型


封装(Encapsulation)

数据隐藏
如何隐藏数据？

使用公有与私有这两个存取修饰符(access modifier)


封装的基本原则：将你的实例变量标记为私有的，并提供公有的
getter与setter来控制存取动作

将实例变量标记为private

任何有值可以被运用到的地方，都可以调用方法的方式取得该类型的值



int x = 3+24;

int x = 3+one.getSize();


数组中对象的行为
数组中的对象的行为


数组中的对象就如同其他的对象一样。唯一的差别就是如何取数
不同处在于如何取得亚空气。


1.声明一个装载7个Dog引用的Dog数组

Dog[] pets;
pets = new Dog[7];

2. 创建两个Dog对象并赋值为数组的前两项元素

pets[0] = new Dog();
3. 调用这两个Dog对象的方法

pets[0].setSize(30);
int x = pets[0].getSize();
pets[1].setSize(8);


声明与初始化实例变量


int size;
String name;


实例变量永远都会有默认值。如果你没有明确的赋值给实例
变量，或没有调用setter,实例变量还是会有值！



声明与初始化实例变量

实例变量永远都会有默认值。如果你没有明确的复制给实例变量，或
没有调用setter,实例还是会有值！

integers 0
floating points 0.0
booleans false
references null

无需初始实例变量，因为它们会有默认值。

数字的primitive(包括char)的预设为0

boolean的预设为false,而对象引用则为null

要记得null代表没有凑走对象的远程控制，它是个引用而不是对象


实例变量与局部变量之间的差别

局部变量没有默认值！如果在变量被初始前就要使用的话，编译器会显示错误


1. 实例变量是声明在类内而不是方法中

class Horse{
	private double height =15.2;
	private String breed;
	}


2.局部变量是声明在方法中的

class AddThing{
	int a;
	int b =12;
	public int add(){
		int total =a+b;
		return total;
	}}


3.局部变量在使用前必须初始化

class Foo{
	public void go(){
		int x ;
		int z = x+3;
}
}

方法的参数基本上与局部变量是相同的---它们都是在方法中声明的(精确地
说应该是方法的参数列声明的，但相比较与实例变量来说它也算是局部的)
而参数并没有未声明的问题，所以编译器也不可能对这样事情显示出错误


这是因为如果调用方法而没有赋值参数时编译器就会显示错误
所以说参数一定会被初始化，编译器会确保方法被调用时会有与声明所相符的
参数，且参数会自动地被赋值进去

变量的比较(primitive主数据类型或引用)


使用==来比对primitive主数据而理性

int a =2;
byte b =3;
if (a==b){}

使用==来判别两个引用是否都指向同一对象

Foo a = new Foo();
Foo b  =new Foo();


Foo c =a;
if (a==b){//false}

if (a==c){//true}

由于字节组合相等，所以使用==会返回值

使用==来比较两个primitive主数据类型，或判断两个
引用是否引用同一个对象

使用equals()来判断两个对象是否在意义上相等

第 5章  超强力方法

让方法产生更大的作用

首先进行高层设计

需要类和方法，

开发类
伪代码  测试码  真实ma 

1.找出类应该做的事情
2.列出实例变量和方法
3.编写方法的伪码
4.编写方法的测试用程序
5.实现类
6.测试方法
6.除错或重新设计


伪码
伪码能帮你专注于逻辑而不需要顾虑到程序语法

测试码
测试用的程序代码
真实码

实际设计出的真正java程序代码


思索与编写测试用的程序代码能够帮助你了解被测的
程序应该要做哪些事情

将string转换成int

Integer.parseInt("3")
java内建类  

for循环

for(int cell:locationCells){}

声明出带有数组元素的变量。在循环的每次循环中，此变量的值
都会带有不同的数组严肃，直到跳出循环位置

要被逐个执行过的数组，每循环一次数组的下一个元素都赋值给变量"cell"


后递增操作符

numOfHits++

中止指令  break;

每次使用单边大号的时间不要太久。
周期性地交换以大脑两侧轮流休息，左脑活动包括循序渐进的工作，
解决逻辑问题与分析，而右脑活动包括了隐喻，创造性思考，模式匹配与可视化


你的java程序应该从高层的设计开始

你通常会在创建新的类时
伪码
测试码
真实码

伪码应该描述要做什么事情而不是如何做
使用伪码来帮助测试码的设计
实现方法之前应该要编写测试码


如果知道要执行多少次，应该要使用for循环而不是while循环


使用前置或后置的递增为变量加1(比如x++)

使用前置或后置的递减堆变量减1(比如x--)


使用Integer.parseInt()来取得String的整数值


Integer.parseInt()只会在所给的String为数字时有作用


使用break命令提前跳出循环



1. 产生随机数

int randomNum =(int)(Math.random()*5)

声明一个保存随机数的变量

java内建的类
math这个类的内含的一个方法



2.取得玩家输入

String guess = helper.getUserInput("enter a number");


基本(非加强版)的for循环

for(int i=0;i<100;i++){}


初始化，boolean测试，重复表达式(后递增运算符)，重复执行的部分放在{}


for (int i=0;i<8;i++){
	System.out.println(i);
}


System.out.println("done");


比较for循环与while循环的差别

while循环只有boolean测试；它并没有内建的初始化或重复表达式

while适合用在不知道要循环几次的循环上。


int i =0;
while (i<8){
	System.out.println(i);
	i++;
}
}


必须得声明病初始化计数器变量

将计数器递增

加强版的for循环

for(String name:nameArray){}


数组元素的类型必须与循环变量的类型匹配
声明会带有数组单一元素的循环变量
此变量在循环过程中会带有不同元素的值

冒号: 代表in

要被逐个运行的集合

重复执行的部分放在{}


声明循环变量
要运行的结集合

第6章 认识java的api

使用java函数库


ArrayList是java函数库中的另一个类

ArrayList

add()  向list中加入对象参数
remove()  在索引参数中移除对象
remove() 移除该对象
contains() 如果和对象参数匹配返回"true"
isEmpty() 如果list中没有元素返回"true"

indexOf() 返回对象参数的索引或-1
size() 返回list中元素的一个数

get() 返回当前索引参数的对象


创建
ArrayList myList = new ArrayList();


	
加入元素

Egg s = new Egg();

myList.add(s);


再加入元素

Egg b = new Egg();

myList.add(b);


查询大小

int theSize = myList.size();


查询特定元素

boolean isIn =myList.contains(s);


查询特定元素的位置

int idx = myList.indexOf(b);


判断集合是否为空

boolean empty = myList.isEmpty();


删除元素

myList.remove(s);


比较ArrayList与一般数组

一般数组咋在创建时就必须确定大小，对于ArrayList,只需要创建出
此类型的对象即可，不需要指定大小，因为它会在加入或删除元素时就
自动地调整大小


存放对象给一般数组时必须指定位置

一般数组使用特殊的语法


声明变量
声明方法
实现方法


与运算符能  &&
或运算  ||


不等于  ！= ！


使用函数库


在java的api中，类是被包装在包中

要使用api中的类，必须知道它放在哪个包中


在java函数库中的每个类都属于某个包，这些包都有名字
ArrayList是放在java.util保重的


System(System.out.println)
String与math(Math.Random())都属于java.lang这个包


必须指明程序代码中所使用到的类的完整名称

java.util.ArrayList

包的名称.类的名称


告诉java想要使用的是哪个ArrayList，有两种方法可以指定


1.import 

放一个import 

import java.util.ArrayList;
public class MyClass{...}

2. type
或在程序代码中打出全名。不管在在哪里，只要有使用就打出全名

声明的时候：

java.util.ArrayList<Dog> list = new java.util.ArrayList<Dog>();


用在参数的时候：

public void go(java.util.ArrayList<Dog>list){}

作为返回类型的时候：


public java.util.ArrayList<Dog> foo() {...}

为何需要全名，由包来决定？


包之所以重要用3个原因：

首先，它们可以帮助组织项目或函数库相对于一大堆零数的类，以功能来组织会比较好


其次，包可以制造出名称空间，以便错开相同名称的类。

最后，包可以通过限制同一包之间的类才能相互存取以维护安全性


要如何防止包的名称也产生冲突？

如果每个程序员都遵循的话，java的命名传统就能防止包名冲突


ArryaList是个java api的类

使用add()来新增ArrayList的元素

使用remove()来删除ArrayList中的元素

要寻找某项元素的位置，使用indexOf()


使用isEmpty()来判别ArrayList是否为空

要取的ArrayList的大小，可以使用size()方法

传统的数组可以用length这个变量取得大小


ArrayList会自动地调整大小


你可以用参数类型来声明数组内容的类型，例如ArrayList<Button>会声明
带有Button类型元素的ArraryList


虽然ArrayList只能携带对象而不是primitive主数据了那些个
但是编译器能够自动地将primitive主数据类型包装成Object以存放在ArrayList中


类会用包来组织

类有完整的名称，那是由包的名称与类的名称所组成的。
ArrrayList事实上叫做java.util.ArrayList


除了java.lang之外，使用到其他的包的类都需要指定全名


也可以在原始程序代码的最开始部分下import 指令来说明所使用到的包


为什么不用import String类或System类

要记得java.lang是个预先被引用的包。因为java.lang是个预先被引用的包，
因为java.lang是个经常要的包

实际上应用中，应该会把类包进包中


如何查询api?

1.库中有哪些类？
2.类是做什么的？


第7章  继承与多态


规划程序时要考虑到未来

子类继承父类。继承的关系意味着子类继承了父类的方法。类成员，成员的意思就是实例变量和方法


1.找出具有共同属性和行为的对象 
2.用继承来防止子类中出现重复的程序代码

设计代表共同状态与行为的类
3. 决定子类是否需要让某些行为(也就是方法的实现)有特定不同的运作方式

寻找更多抽象化的机会

4.通过寻找使用共同行为的子类来找出更多抽象化的机会

5. 完成类的集成层次

当你调用对象引用的方法时，你会调用到与该对象类型最接近的方法


继承的顺序？



父类不一定要知道它的子类。
super.增加新的昂发

可以在父类中设计出所有子类都适用的功能实现。
让子类可以不用完全覆盖掉父类的功能，只是再加上额外的行为
你可以通过super这个关键词来取用父类

子类可以继承父类的成员。这包括了实例变量和方法
父类可以通过取得权限决定子类是否能够集成某些特定的长远


private  default protected public


存取权限(access level)控制了谁可以接触可以，这对编写java很重要


public类型的成员会被集成
private类型的成员不会被继承


当子类把成员继承下来时会把它们当做是自己定义的一样。

任一类的成员包含有自己定义出的变量和方法再加上父类所集成下来的任何东西


子类是extends父类出来


子类会继承父类所有public类型的实例变量和方法，但不会继承父类所有private类型的
变量和方法

继承下来的方法可以被覆盖掉，但实例变量不能被覆盖掉

使用IS-A测试来验证继承结构的合理性

IS-A关系是单方向的(矛盾特殊性和普遍性)


当某个方法在子类中被覆盖掉，调用这个方法时会调用到覆盖过的斑斑


如果类Y是extends类X,且类Y是类的父类，则Z应该能通过IS-A X的测试



继承的意义

通过设计继承的过程可以累积面向对象的经验值。通过提取出一组类间共同的抽象性
你能够排除掉重复的程序diamante而将这个部分放在父类中

如果有共同的部分需要改变，就只会有一个地方要修改而已，修改只会只需要重新编译就行
不必动子类



换上改变过的父类，则所有扩充过它的类都会自动使用到新版本


java程序只是由一堆类组成的，子类不需要重新编译就能运用新版本的父类。如果父类没有
破坏到子类，就可以


1. 避免了重复的程序代码

在单一的位置定义共同程序代码，然后让子类在继承父类的程序代码，当想要改变这个行为
程序时，只需要修改这个地方，而子类就会发生同样的改变

2. 定义出共同的协议


继承让你可以确保某个父型之下的所有类都会有父型所持有的全部昂发


你会通过继承来定义相关类间的共同协议

若要观察多态是如何运行的，我们就必须先退回去看一般声明和创建对象的方法...

对象声明，创建与赋值

Dog myDog = new Dog();

1.声明一个引用变量

Dog myDog

要求java虚拟机分配空间给引用变量，并将此变量命名为myDog
此引用变量将永远被固定为Dog类型


2. 创建对象

new Dog();

要求java虚拟机分配堆空间给新建立的Dog对象


3. 连接对象和引用

将新的Dog赋值给myDog这个引用变量。

重点在于引用类型与对象的类型必须相符

但在多态下，引用与对象可以是不同的类型


Animal myDog =new Dog();


运用多态时，引用类型可以是实际对象类型的父类


当你声明一个引用变量时，任何对该引用变量类型可通过IS-A 测试的
对象都可以被赋值给该引用。
任何extends过声明引用变量类型的对象都可以被赋值给这个引用变量
这样子你就可以做出多态数组这一类的东西


Animal[] animals = new Animal[5];


animals [0] = new Dog();

animals [1] = new Cat();


for (int i=0;i < animals.length;i++){
	animals[i].eat();
	animals[i].roam();
}


参数和返回类型也可以多态


如果你声明一个父类的引用变量，

class Vet{
	public void giveShot(Animal a){
	a.makeNoise();

}
}


class PetOwner{
	public void start(){
		Vet v = new Vet();
		Dog d = new Dog();
		Hippo h = new Hippo();
		v.giveShot(d);
		v.giveShot(h);
}}


java api的层次不会太深

有三种方法可以防止某个类被作出子类

1.第一种，是存取控制，就算类不能标记为私有，但它还是可以不标记公有，
非公有的类只能被同一个包的类作出子类

2. 第二种，使用final这个修饰符(modifier)这表示
它是继承树的末端，不能被继承

3. 第三种，让类只拥有private的构造程序(constructer)


如果你想要防止特定的方法被覆盖，可以将该方法表示上final这个修饰符，
将这个类标识成final表示没有任何的方法可以被覆盖

覆盖的规则

方法就是合约的标志



参数必须要一样，且返回类型必须要兼容


父类的合约定义出其他的程序地阿妈要如何使用方法。不管父类使用了哪种参数，
覆盖此方法的子类也一定要使用相同的参数。
而不论父类声明的返回类型是什么，子类必须要声明返回一眼的类型或该类型的子类
要记得，子类对象得保证能够执行父类的一切


不能降低方法的存取权限


这代表存取权限必须相同，或更为开发，你不能覆盖掉一个公有的方法并将它标记为私有
这会让它以为在编译期通过的是个公有，然后突然在执行期才被java虚拟机阻止存取


方法的重载(overload)

重载的意义是两个方法的名称相同，但参数不同。所以重载与多态没有关系

重载可以有同一个方法的多个不同参数版本以方便调用。比如，如果某个方法需要int,
调用放就得将double 转换为int然后才能调用。如果你有个重载版本取得double
参数，则这样堆调用方法来说简单得多了


因为重载方法不是用来满足定义在父类的多态合约，所以重载的方法比较有扩展性


重载版的方法只是刚好有相同名字的不同方法，它与继承与多态无关。重载的
方法与覆盖方法不一样


返回类型可以不同

你可以任意地改变重载方法的返回类型，只要所有的覆盖使用不同的参数即可

不能只改变返回类型

如果只有返回类型不同，但参数一样，这就是不允许的。
编译器不会让这样的事情发生，就算是重载，也要让返回类型是父类版返回类型的子类
，重载的条件是要使用不同的参数，此时返回类型可以自由地定义


可以更改存取权限

你可以任意地设定overload版method的存取权限




重载的合法返利

public class Overloads{
	String uniqueID;
	public int addNums(int a,int b){
		return a+b;
	}
	
	pubic double addNums(double a,double b){
		return a+b
	}
	
	public void setUniqueID(String theID){
		uniqueID = theID;
	}

	public void setUniqueID(int ssNumber){
		String numString = "" + ssNumber;
		setUniqueID(numString);
}
}




第8章 接口与抽象类


深入多态


继承只是个开始。要使用多态，我们还需要接口

抽象类是无法初始化的类。抽象类有什么用

接口是多态和java的重点


Wolf aWolt =new Wolf();

abstract class Canine extends Animal{
	public void roam(){
}



编译器不会让初始化的抽象类

抽象类代表没有人能够创建出该类的实例。

abstract public class Canine extends Animal
{
	public void roam(){}
}


public class MakeCanine{
	public void go(){
		Canine c;
		c =new Dog();

		c =new Canine();
		c.roam();
}
}

抽象类除了被继承过之外，是没有用途，没有值，没有目的


抽象与具体

不是抽象的类就被称为具体类。

抽象或具体？

抽象的方法

除了类之外，你也可以将方法标记为abstract的

抽象的类代表此类必须要被extend过，抽象的方法代表此方法一定要被覆盖过。
抽象的方法没有实体

public abstract void eat();

没有方法体！直接以分号结束

如果你声明出一个抽象的方法，就必须将类也标记为抽象的。
你不能在非抽象类中拥有抽象方法

就算只有一个抽象的方法，此类也必须标记为抽象的


你必须实现所有抽象的方法


实现抽象的方法就如同覆盖过方法一样

抽象的方法没有内容，它只是为了标记出多态而存在的。这表示在继承树结构下的
第一个具体必须要实现出所有的抽象方法


抽象类与具体类


ArrayList

boolean remove() 根据索引参数移动对象，如果list中没有元素返回true

boolean contains() 如果和对象的参数相匹配的话返回true

boolean isEmpty() 如果list中没有元素返回true

int indexOf() 返回对象参数的索引值或-1


Object get(int index) 返回元素在list中的位置


boolean add() 向list中增加元素


在java中的所有类都是从Object这个类继承出来的


Object这个类是所有类的源头；它是所有类的父类


没有直接继承过其他类的类回事隐含的继承对象

Object不是正式的Java抽象类。因为它可以被所有类继承下来的方法
都实现程序代码。所以没有必要被覆盖过的方法

允许创建出Object实例
因为需要一个通用的对象，一个轻量化的对象。它最常见的用途是用在线程的同步化

编译器是根据引用类型来判断有哪些method可以滴啊用，而不是根据Object确实的而理性


编译器还是会把它当做一般的Object来看待。编译器只管引用的类型，而不是对象的类型


多态意味着很多形式

当你把对象装进ArrayList<Object>时，不管它原来是什么，你只能把它当做Object

从ArrayList<Object>取出引用时，引用的类型只会是Object

这代表你只会取得Object的遥控器




java的接口就好像是100%的纯抽象类

所有接口的方法都是抽象的，所以任何Pet的类都必须要实现这些方法

接口的定义

public interface Pet{}

接口的实现


public class Dog extends Canine implements Pet{}


使用implements 这个关键词，注意到实现interface时还是必须
在某个类的继承之下


public interface Pet{
	public abstract void beFriendly();
	public abstract void play();

}



public class Dog extends Canine implements Pet{
	public void beFriendly(){}

	public void play(){}
	
	public void roam(){}
	public void eat(){}

}


接口有无比的适用性，若你以接口取代具体的子类或抽象的父类作为
参数或返回类型，则你就可以传入任何有实现该接口的东西。
使用接口就可以继承超过一个以上的来源

类可以extend 过某个父类，并且实现其他的接口。同时其他的类也可以实现
同一个接口，因此你就可以为不同的需求组合出不同的继承层次

不同继承树的类也可以实现相同的接口


在继承中也有super来继承父类中的方法


如果你不想让某个类被初始化，就以abstract这个关键词将它标记为抽象的


抽象的类可以带有抽象和非抽象的方法

如果类带有抽象的方法，则此类必定表示为抽象的

抽象的方法必须在具体的类中运行

java所有的类都是Object的参数或返回类型

不管实际上所引用的对象是什么类型，只有在引用变量的类型就是
带有某方法的类型时才能调用该方法


Oject引用变量在没有类型转换的情况下不能赋值给其他的类型，
若堆上的对象类型与索要转换的类型不兼容，则此转换会在执行期产生异常


从ArrayList<Object>取出的对象只能被Object引用，不然就要用类型转换来改变

java不允许多重继承

接口就好像是100%穿天然抽象类

以interface这个关键词取代class来声明接口

实现接口时要使用implements这个关键词

例如：Dog implements Pet

跑229
class 可以实现多个接口



